---
title: How it works
description: A short explanation of the mechanics behind Safeparts.
---

Safeparts is built around three simple goals:

1. Split a secret so no single share reveals it.
2. Reconstruct only when enough shares show up.
3. Fail loudly when inputs are wrong (wrong shares, typos, wrong passphrase).

## Threshold sharing (k-of-n)

You choose a threshold (<var>k</var> of <var>n</var>):

- With fewer than <var>k</var> shares, reconstruction is impossible.
- With any <var>k</var> shares, reconstruction succeeds.

Under the hood, this is Shamir-style secret sharing over a finite field (<span class="token token--mono">GF(256)</span>), applied byte-wise.

### What a share is

Conceptually, each share is one point on a polynomial of degree <var>k</var>-1.
With <var>k</var> points you can reconstruct the polynomial, and therefore the original secret.
With fewer than <var>k</var> points, you learn nothing useful about the secret.

### Why <span class="token token--mono">GF(256)</span>

Safeparts works on bytes. <span class="token token--mono">GF(256)</span> lets the math happen on 8-bit values, so secret sharing applies cleanly to arbitrary binary data.

## Integrity

Secret sharing gives you confidentiality (until <var>k</var> shares), but by itself it does not reliably catch user mistakes.
Safeparts adds an integrity tag so combine can detect incorrect inputs.

- If shares are corrupted or from different sets, combine fails.
- If you typed a share wrong, combine fails.

There are also extra checks at the encoding layer:

- Base58Check includes a checksum.
- Mnemonic shares include CRC16 to catch many transcription mistakes.

## Optional passphrase protection

Safeparts can encrypt the secret before splitting it.

High level:

- Derive a key from the passphrase (Argon2id).
- Encrypt the secret (ChaCha20-Poly1305).
- Split the encrypted bytes into shares.

This means an attacker needs both <var>k</var> shares and the passphrase.

:::note
Passphrases add a second requirement; they do not replace good share separation.
:::

## Encodings

Shares can be encoded for different workflows:

- machine-friendly (copy/paste): base64url, base58check
- human-friendly (transcription): mnemonic formats

See [Encodings](encodings/).

## Packet metadata (why shares must match)

Shares are not just chunks. Each share carries enough metadata to prove it belongs to the same set:

- threshold (<var>k</var>) and share count (<var>n</var>)
- set identity / versioning
- integrity data

That is why mixing shares from different splits should fail loudly.

## What Safeparts does not do

- It does not keep shares safe for you. Storage choices are the security boundary.
- It does not protect you from someone who legitimately holds <var>k</var> shares.

:::note
For a deeper security-focused explanation (data flow, algorithm choices, and recommended procedures), see [Technical design](technical-design/).
:::

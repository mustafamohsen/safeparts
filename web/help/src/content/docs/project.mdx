---
title: How it works
description: A short explanation of the “science” behind Safeparts.
---

Safeparts is built around three ideas:

1. Split a secret so no single share reveals it.
2. Reconstruct only when enough shares agree.
3. Detect mistakes (wrong shares, typos, wrong passphrase).

## Threshold sharing (k-of-n)

You choose a threshold (<var>k</var> of <var>n</var>):

- With fewer than <var>k</var> shares, reconstruction is impossible.
- With any <var>k</var> shares, reconstruction succeeds.

Under the hood, this is Shamir-style secret sharing over a finite field (GF(256)), applied byte-wise.

## Integrity

Safeparts adds an integrity tag so reconstruction can detect incorrect inputs.

- If shares are corrupted or from different sets, combine fails.
- If you typed a share wrong, combine fails.

## Optional passphrase protection

Safeparts can encrypt the secret before splitting it.

High level:

- Derive a key from the passphrase (Argon2id).
- Encrypt the secret (ChaCha20-Poly1305).
- Split the encrypted bytes into shares.

This means an attacker needs both <var>k</var> shares and the passphrase.

:::note
Passphrases add a second requirement; they do not replace good share separation.
:::

## Encodings

Shares can be encoded for different workflows:

- machine-friendly (copy/paste): base64url, base58check
- human-friendly (transcription): mnemonic formats

See [Encodings](encodings/).

## What Safeparts does not do

- It does not keep shares safe for you. Storage choices are the security boundary.
- It does not protect you from someone who legitimately holds <var>k</var> shares.

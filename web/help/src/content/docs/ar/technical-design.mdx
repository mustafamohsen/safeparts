---
title: التصميم التقني
description: كيف يعمل Safeparts تقنياً، ولماذا تم اختيار خوارزميات التشفير، وكيف تُنفذ إجراءات تقسيم/استرداد آمنة.
---

هذه الصفحة مقالة تقنية تركيزها على الأمان. الهدف هو شرح *الإجراءات* و*قرارات التصميم* وليس تفاصيل الشيفرة.

إذا كنت تبدأ لأول مرة، ابدأ بـ [دليل البدء](getting-started/) و[الأمان](security/).

## ما هو Safeparts (وما الذي ليس هو)

Safeparts أداة استرداد تعتمد على <span class="token" dir="ltr">k من n</span> مبنية على Shamir secret sharing.

- أقل من <var>k</var> حصص: الاسترداد غير ممكن.
- أي <var>k</var> حصص من نفس المجموعة: الاسترداد ينجح.

هو **ليس** نظام تخزين. خطة التخزين والتوزيع لديك هي حد الأمان الحقيقي.

## تدفق البيانات من البداية للنهاية

Safeparts يضع طبقات مقصودة لتقليل الأخطاء التشغيلية (حصة خاطئة، خطأ كتابة، خلط مجموعات) مع خيار إضافة عامل ثانٍ (عبارة مرور).

```text
تدفق التقسيم
------------
بايتات السر
  |
  | (اختياري) حماية بعبارة مرور
  |   - Argon2id(passphrase, salt, parameters) -> مفتاح 32 بايت
  |   - ChaCha20-Poly1305(key, nonce) -> نص مشفّر
  |
  | data_to_split = نص صريح أو نص مشفّر
  |
  | integrity tag = BLAKE3(data_to_split)   (32 بايت)
  | tagged = data_to_split || integrity tag
  |
  | Shamir split(tagged, k, n, set_id) -> n حصص
  |
  | تغليف كل حصة داخل SharePacket ذاتية الوصف
  |
  | ترميز للحفظ/النقل (base64url | base58check | mnemonic)
```

```text
تدفق الاسترداد
-------------
فك ترميز الحصص -> SharePackets
  |
  | التحقق من تطابق البيانات التعريفية (set_id, k, n, x, crypto params)
  |
  | Shamir combine -> بايتات tagged
  |
  | تقسيم tagged إلى (data_to_split, integrity tag)
  | التحقق: BLAKE3(data_to_split) == integrity tag
  |
  | إذا كانت مشفّرة:
  |   Argon2id(passphrase, salt, parameters) -> key
  |   ChaCha20-Poly1305 decrypt(key, nonce) -> secret
  |
  +-> إخراج بايتات السر
```

## بنية البيانات عند التقسيم

يتعامل Safeparts مع الإدخال كـ مصفوفة بايتات ويقسمه **بايتاً ببايت**. مدخل التقسيم هو:

- `data_to_split` (نص صريح أو نص مشفّر)
- يتبعه وسم سلامة BLAKE3 بطول 32 بايت

ليكن طول الحمولة الموسومة `L` بايت. عند كل موضع بايت `i`:

1. تُفسر البايت كحد ثابت متعدد حدود من الدرجة <var>k</var>-1 في <span class="token token--mono" dir="ltr">GF(256)</span>.
2. تُولّد معاملات عشوائية عددها <var>k</var>-1 (متعدد حدود مستقل لكل موضع).
3. يُقيّم متعدد الحدود عند `x = 1..n` لإنتاج `n` بايتات ناتجة.

حمولة كل حصة هي تسلسل قيم `y` عبر جميع المواضع `L`، لذلك يكون طول كل حصة مساوياً لطول الحمولة الموسومة. وتخزن الحزمة قيمة `x` الخاصة بها، مع `k` و`n` و`set_id`، بحيث يمكن إعادة التركيب من أي <var>k</var> حصص وتُستعاد كل بايت على حدة.

## تفاصيل المشاركة بالعتبة

### Shamir secret sharing فوق GF(256)

Safeparts يستخدم Shamir secret sharing فوق المجال المنتهي <span class="token token--mono" dir="ltr">GF(256)</span> بشكل byte-wise.

انعكاسات عملية:

- **يعمل مع أي سر ثنائي**: السر مجرد بايتات (ملفات، مفاتيح، عبارات، إلخ).
- **حد أعلى لعدد الحصص**: في <span class="token token--mono" dir="ltr">GF(256)</span> يوجد 256 عنصر. يحجز Safeparts القيمة <span class="token token--mono" dir="ltr">x = 0</span> لإعادة التركيب، لذلك <span class="token token--mono" dir="ltr">1 &lt;= n &lt;= 255</span>.
- **لا تسريب للبنية**: أقل من <var>k</var> حصص لا تعطي معلومات مفيدة عن بايتات السر.

### لماذا GF(256) بدلاً من مجال أولي كبير

بعض تطبيقات Shamir تمثل السر كعدد كبير <span class="token" dir="ltr">mod prime</span>.
Safeparts يختار <span class="token token--mono" dir="ltr">GF(256)</span> لأن التعامل مع البايتات مباشر وفعّال ولا يحتاج قواعد packing إضافية.

المقابل هو حد 255 حصة لكل مجموعة، وهو عادةً أعلى بكثير مما تحتاجه خطط الاسترداد الواقعية.

## حزم الحصص والبيانات التعريفية (تقليل الأخطاء)

حصص Safeparts ليست نقاطاً خاماً <span class="token" dir="ltr">(x, y)</span> فقط.
كل حصة تُغلف داخل حزمة ذاتية الوصف ومُصدَّرة بإصدار حتى:

- يصبح خلط حصص من مجموعات مختلفة أصعب بالخطأ.
- تستطيع طبقة الفك رفض المدخلات المبتورة/التالفة.
- تُحمل إعدادات التشفير (إن وُجدت) مع مجموعة الحصص.

شكل الحزمة (مبسّط):

```text
SharePacket
----------
magic      : "SMN1"
version    : u8
flags      : u8   (مثال: encrypted)
k, n, x    : u8, u8, u8
set_id     : 16 بايت (معرّف عشوائي لمجموعة الحصص)

إذا كانت مشفّرة:
  salt         : 16 بايت
  nonce        : 12 بايت
  argon mem    : u32 (KiB)
  argon time   : u32
  argon par    : u32

payload_len: u32
payload    : bytes   (بيانات الحصة)
```

ملاحظة أمنية: البيانات التعريفية (مثل <var>k</var> و<var>n</var> وطول الحمولة) ليست سرية. السرية تأتي من المشاركة بالعتبة ومن (اختيارياً) التشفير.

## السلامة: لماذا يوجد وسم BLAKE3

Shamir يعطي سرية حتى <var>k</var> حصص، لكنه وحده لا يكشف أخطاء المستخدم دائماً.
على سبيل المثال، إدخال حصة خاطئة قد ينتج مخرجات *ما* دون أن تعرف أنها خاطئة.

لذلك يضيف Safeparts وسم سلامة بطول 32 بايت:

- أثناء التقسيم: حساب <span class="token token--mono" dir="ltr">BLAKE3(data_to_split)</span> وإلحاقه.
- أثناء الاسترداد: إعادة الحساب والمقارنة؛ إن لم يتطابق يفشل الاسترداد.

ماذا يفيد هذا الوسم؟

- كشف تلف الحصص (نسخ/لصق خاطئ، تخزين تالف).
- كشف خلط مجموعات مختلفة.
- التحقق من نص مشفّر مُعاد تركيبه بدون معرفة عبارة المرور.

وماذا **ليس** هو؟

- ليس <span class="token" dir="ltr">MAC</span> بمفتاح، ولا يوفر أصالة ضد مهاجم يملك <var>k</var> حصص.
  (إذا امتلك مهاجم <var>k</var> حصص، فالسرية ضاعت بالفعل.)

### لماذا BLAKE3 (وليس SHA-256 مثلاً)

BLAKE3 اختيار مناسب كـ hash حديث وسريع:

- سريع على أغلب المعالجات.
- مناسب للتوازي والتجزئة (incremental).
- تصميم محافظ وله سلالة قوية (مبني على BLAKE2).

استخدام <span class="token token--mono" dir="ltr">SHA-256</span> ممكن أيضاً كـ checksum بعد الاسترداد. اختيار BLAKE3 هنا بالأساس قرار أداء وملاءمة.

## حماية اختيارية بعبارة مرور

Safeparts يستطيع تشفير السر *قبل* المشاركة بالعتبة.
هذا يجعل الاسترداد يتطلب عاملين:

- شيء تملكه: على الأقل <var>k</var> حصص
- شيء تعرفه: عبارة المرور

### لماذا encrypt-then-split

تشفير السر مرة واحدة ثم تقسيمه يعطي ميزتين:

- يمكنك التحقق من صحة الحصص (عبر وسم BLAKE3) **بدون** عبارة المرور.
- لا يتم فك التشفير إلا بعد التأكد من تطابق مجموعة الحصص.

### لماذا Argon2id لاشتقاق المفتاح

إذا حصل مهاجم على <var>k</var> حصص، يمكنه إعادة تركيب النص المشفّر ومحاولة تخمين عبارة المرور بشكل offline.
وظيفة <span class="token" dir="ltr">KDF</span> هي جعل هذه المحاولة مكلفة.

Argon2id يُنصح به على نطاق واسع لأنه:

- <span class="token" dir="ltr">Memory-hard</span> (أصعب على GPU/ASIC من PBKDF2).
- يقلل بعض مخاوف side-channels مقارنة بـ Argon2d.
- قابل للضبط (وقت/ذاكرة/توازي) بحيث يمكن رفع الكلفة مستقبلاً.

Safeparts يخزن إعدادات Argon2 داخل الحصص كي لا تنكسر حصص قديمة إذا تغيرت الافتراضات الافتراضية.

الإعدادات الافتراضية الحالية (قد تتغير) تقريباً:

- الذاكرة: 64 MiB
- time cost: 3
- parallelism: 1

### لماذا ChaCha20-Poly1305 للتشفير

<span class="token token--mono" dir="ltr">ChaCha20-Poly1305</span> هو <span class="token" dir="ltr">AEAD</span> (تشفير مُصادق عليه).
يوفر:

- سرية: لا يمكن معرفة السر دون المفتاح.
- سلامة/أصالة للنص المشفّر: عبارة مرور خاطئة أو عبث بالبيانات يؤدي إلى فشل فك التشفير.

يُستخدم كثيراً في الأدوات متعددة المنصات لأنه سريع وثابت زمنياً حتى على أنظمة لا تملك تسريع AES.

<span class="token token--mono" dir="ltr">AES-GCM</span> بديل قوي ومعياري أيضاً؛ اختيار ChaCha20-Poly1305 هنا أساسه الاتساق في الأداء والسلوك عبر الأجهزة.

## الترميزات (سلامة بشرية وآلية)

الترميز يتعلق بـ *الموثوقية التشغيلية*: هل يمكنك حفظ الحصة وإعادة إدخالها لاحقاً دون أخطاء؟

- <span class="token" dir="ltr">base64url</span>: صغير ومناسب للأتمتة.
- <span class="token" dir="ltr">base58check</span>: يتجنب أحرفاً ملتبسة ويضيف checksum.
- <span class="token" dir="ltr">mnemo-words</span>: كلمات + CRC16 لكشف كثير من أخطاء الكتابة.
- <span class="token" dir="ltr">mnemo-bip39</span>: عبارات صالحة وفق BIP-39 مع framing للحزم متعددة الأجزاء.

راجع [الترميزات](encodings/) لاختيار الصيغة.

## إجراءات أمان موصى بها

### إجراء التقسيم (إنشاء الحصص)

1. اختر <var>k</var> و<var>n</var> بناءً على أشخاص ومواقع يمكنك تنسيقها واقعياً وقت الضغط.
2. استخدم بيئة نظيفة:
   - يفضّل offline.
   - عطّل سجل الحافظة (clipboard history) وتسجيل الشاشة إن أمكن.
   - تجنب الأدوات التي تسجل المدخلات.
3. إن استخدمت عبارة مرور:
   - استخدم عبارة مرور عالية العشوائية.
   - تجنب تمريرها في سطر الأوامر؛ يفضّل ملفاً حيث يتوفر ذلك.
4. أنشئ الحصص.
5. وزع الحصص عبر أسباب فشل مستقلة (أشخاص/أجهزة/مواقع).
6. احتفظ بـ runbook يوضح من يحمل أي حصة وكيف تتواصل معه.
7. نفّذ تجربة استرداد (يفضل أولاً بسر اصطناعي ثم بالخطة الفعلية).

### إجراء الاسترداد (جمع الحصص)

1. اجمع على الأقل <var>k</var> حصص.
2. فك ترميزها في بيئة مضبوطة.
3. نفذ الاسترداد والتحقق من السلامة (Safeparts يقوم بذلك تلقائياً).
4. إن كانت مشفرة، فك التشفير باستخدام عبارة المرور.
5. تعامل مع الناتج كبيانات حساسة:
   - تجنب حفظه على القرص إلا للضرورة.
   - دوّر/بدّل السر إذا تم الاسترداد في بيئة غير موثوقة.

### عند الشك في تسرب أو اختراق

- إذا شككت أن حصة نُسخت أو صُورت أو سُرقت، اعتبرها مخترقة.
- إذا كان من المحتمل أن يصل عدد الحصص المخترقة إلى <var>k</var>، اعتبر السر مخترقاً.
- الأفضل عملياً: استرداد السر، تدويره (إن أمكن)، ثم إعادة تقسيمه لمجموعة جديدة.

## الحدود / ما لا يقدمه Safeparts

- لا يوجد <span class="token" dir="ltr">VSS</span> (verifiable secret sharing): حامل حصة خبيث يمكنه إعطاء حصة خاطئة والتسبب في فشل الاسترداد.
- لا يوجد تحديث للحصص بدون استرداد السر.
- لا حماية إذا امتلك ائتلاف شرعي <var>k</var> حصص.
- أمان عبارة المرور يعتمد على قوتها؛ Argon2id يرفع الكلفة لكنه لا يحمي عبارة مرور ضعيفة.

لجانب التخطيط البشري، راجع [حالات الاستخدام](use-cases/) و[الأمان](security/).
